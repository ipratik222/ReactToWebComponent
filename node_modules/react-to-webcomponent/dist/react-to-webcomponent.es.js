const y = Symbol.for("r2wc.reactRender"), N = Symbol.for("r2wc.shouldRender"), b = Symbol.for("r2wc.root");
function E(r = "") {
  return r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function w(r) {
  return r.split("").every((c) => c.toUpperCase() === c);
}
function A(r) {
  return Array.isArray(r) && r.length === 1 ? r[0] : r;
}
function S(r, c) {
  var n;
  if (c.nodeType === Node.TEXT_NODE)
    return (n = c.textContent) == null ? void 0 : n.toString();
  const s = Array.from(c.childNodes).map((i) => {
    var a;
    if (i.nodeType === Node.TEXT_NODE)
      return (a = i.textContent) == null ? void 0 : a.toString();
    const l = w(i.nodeName) ? i.nodeName.toLowerCase() : i.nodeName, u = A(S(r, i)), m = {};
    for (const d of i.getAttributeNames())
      m[d] = i.getAttribute(d);
    return r.createElement(l, m, u);
  });
  return A(s);
}
const T = {
  expando: function(r, c, s) {
    Object.defineProperty(r, c, {
      enumerable: !0,
      get: function() {
        return s;
      },
      set: function(n) {
        s = n, this[y]();
      }
    }), r[y]();
  }
};
function x(r, c, s, n = {}) {
  const i = {}, l = {}, u = {};
  n.props || (n.props = r.propTypes ? Object.keys(r.propTypes) : []), (Array.isArray(n.props) ? n.props.slice() : Object.keys(n.props)).forEach((o) => {
    var e;
    i[o] = Array.isArray(n.props) ? String : (e = n.props) == null ? void 0 : e[o], l[o] = E(o), u[l[o]] = o;
  });
  const a = {
    isConnected: "isConnected" in HTMLElement.prototype
  };
  let d = !1;
  const h = function(...o) {
    const e = Reflect.construct(HTMLElement, o, this.constructor);
    return typeof n.shadow == "string" ? e.attachShadow({ mode: n.shadow }) : n.shadow && (console.warn('Specifying the "shadow" option as a boolean is deprecated and will be removed in a future version.'), e.attachShadow({ mode: "open" })), e;
  }, p = Object.create(HTMLElement.prototype);
  p.constructor = h;
  const C = new Proxy(p, {
    has: function(o, e) {
      return e in i || e in p;
    },
    set: function(o, e, t, f) {
      return d && (a[e] = !0), typeof e == "symbol" || a[e] || e in o ? (r.propTypes && e in r.propTypes && typeof e == "string" && T.expando(f, e, t), Reflect.set(o, e, t, f)) : (T.expando(f, e, t), !0);
    },
    getOwnPropertyDescriptor: function(o, e) {
      const t = Reflect.getOwnPropertyDescriptor(o, e);
      if (t)
        return t;
      if (e in i)
        return {
          configurable: !0,
          enumerable: !0,
          writable: !0,
          value: void 0
        };
    }
  });
  return h.prototype = C, p.connectedCallback = function() {
    this[N] = !0, this[y]();
  }, p.disconnectedCallback = function() {
    s.createRoot && typeof s.createRoot == "function" ? this[b].unmount() : s.unmountComponentAtNode && s.unmountComponentAtNode(this);
  }, p[y] = function() {
    if (this[N] === !0) {
      const o = {};
      Object.keys(this).forEach(function(g) {
        a[g] !== !1 && (o[g] = this[g]);
      }, this), d = !0;
      const e = n.shadow ? this.shadowRoot : this, t = A(S(c, this)), f = c.createElement(r, o, t);
      s.createRoot && typeof s.createRoot == "function" ? (this[b] || (this[b] = s.createRoot(e)), this[b].render(f)) : s.render && s.render(f, e), d = !1;
    }
  }, h.observedAttributes = Object.keys(u), p.attributeChangedCallback = function(o, e, t) {
    const f = u[o] || o;
    switch (i[f]) {
      case "ref":
      case Function:
        if (!t && i[f] === "ref") {
          t = c.createRef();
          break;
        }
        typeof window < "u" ? t = window[t] || t : typeof global < "u" && (t = global[t] || t), typeof t == "function" && (t = t.bind(this));
        break;
      case Number:
        t = parseFloat(t);
        break;
      case Boolean:
        t = /^[ty1-9]/i.test(t);
        break;
      case Object:
      case Array:
        t = JSON.parse(t);
        break;
    }
    this[f] = t;
  }, h;
}
export {
  x as default
};
